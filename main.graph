// basic structs
Vector2 :: struct {
    x: float;
    y: float;
}
// vector 2 operators
add :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x + b.x, a.y + b.y };
}

sub :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x - b.x, a.y - b.y };
}

mul :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x * b.x, a.y * b.y };
}

mul_s :: (a: Vector2, s: float) -> Vector2 {
    <- { a.x * s, a.y * s };
}

div :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x / b.x, a.y / b.y };
}

length :: (v: Vector2) -> float {
    <- sqrt(v.x * v.x + v.y * v.y);
}

normalized :: (v: Vector2) -> Vector2 {
    size := length(v);
    <- { v.x / size, v.y / size };
}

Vector2i :: struct {
    x: int;
    y: int;
}

Circle :: struct {
    centre: Vector2;
    radius: float;
}

Color :: struct {
    r: float;
    g: float;
    b: float;
    a: float;
}

set_color :: (color: *Color){
    extern_set_colour(color.r, color.g, color.b, color.a);
}

get_mouse_position :: () -> Vector2i {
    <- { get_mouse_x(), get_mouse_y() };
}

Ball :: struct {
    position: Vector2;
    previous_position: Vector2;
    acceleration: Vector2;
    radius: float;
}

accelerate :: (ball: *Ball, a: Vector2){
    ball.acceleration.x = ball.acceleration.x + a.x;
    ball.acceleration.y = ball.acceleration.y + a.y;
    <-;
}

update_position :: (ball: *Ball, delta: float){
    velocity := sub(ball.position, ball.previous_position);
    prev: Vector2 = ball.position;
    ball.previous_position = prev;

    ball.position = add(ball.position, add(velocity, mul_s(ball.acceleration, delta * delta)));
    ball.acceleration = { 0. , 0. };
    <-;
}

constrain_to_circle :: (ball: *Ball, circle: *Circle){
    displacement := sub(ball.position, circle.centre);
    if length(displacement) > circle.radius - ball.radius {
        value : Vector2 = add(circle.centre, mul_s(normalized(displacement), circle.radius - ball.radius));
        ball.position = value;
    }
}

get_balls :: () -> [200]Ball {
    balls: [200]Ball;
    i := 1;
    for ball in balls {
        ball.radius = 10.;
        ball.position = { 400. + float(i) * (ball.radius * 2.0), 500. };
        ball.previous_position = { 400. + float(i) * (ball.radius * 2.0), 500. + float(i) * 0.01 };
        ball.acceleration = { 0., 9.81 };
        i = i + 1;
    }
    <- balls;
}

main :: () {

    window_width := 1500;
    window_height := 1000;

    open_window(window_width, window_height);

    // colours
    orange: Color = { 1., 0.3 + 0.2, 0., 1. };
    blue:   Color = { 0., 0., 1., 1. };
    black:  Color = { 0., 0., 0., 1. };

    gravity: Vector2 = { 0. , 9.81 * 10. };

    balls := get_balls();

    environment: Circle = { { 500. , 500. }, 400. };

    start := time_seconds();
    delta := 0.;

    while true {
        frame_begin();
        set_color(&black);
        fill_rect(0, 0, window_width, window_height);

        set_color(&blue);
        fill_circle(int(environment.centre.x), int(environment.centre.y), int(environment.radius));

        set_color(&orange);

        for ball in balls {
            accelerate(ball, gravity);
        }

        for ball in balls {
            update_position(ball, delta);
            constrain_to_circle(ball, &environment);
        }

        for ball in balls {
            fill_circle(int(ball.position.x), int(ball.position.y), int(ball.radius));
        }

        draw();
        current := time_seconds();
        delta = current - start;
        start = current;
    }
}