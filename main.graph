// basic structs
Vector2 :: struct {
    x: float;
    y: float;
}
// vector 2 operators
add :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x + b.x, a.y + b.y };
}

sub :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x - b.x, a.y - b.y };
}

mul :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x * b.x, a.y * b.y };
}

mul_s :: (a: Vector2, s: float) -> Vector2 {
    <- { a.x * s, a.y * s };
}

div :: (a: Vector2, b: Vector2) -> Vector2 {
    <- { a.x / b.x, a.y / b.y };
}

div_s :: (a: Vector2, s: float) -> Vector2 {
    <- { a.x / s, a.y / s };
}

length :: (v: Vector2) -> float {
    <- sqrt(v.x * v.x + v.y * v.y);
}

normalized :: (v: Vector2) -> Vector2 {
    size := length(v);
    <- { v.x / size, v.y / size };
}

Vector2i :: struct {
    x: int;
    y: int;
}

Circle :: struct {
    centre: Vector2;
    radius: float;
}

Color :: struct {
    r: float;
    g: float;
    b: float;
    a: float;
}

set_color :: (color: *Color){
    extern_set_colour(color.r, color.g, color.b, color.a);
}

get_mouse_position :: () -> Vector2i {
    <- { get_mouse_x(), get_mouse_y() };
}

Ball :: struct {
    position: Vector2;
    previous_position: Vector2;
    acceleration: Vector2;
    radius: float;
    id: int;
}

accelerate :: (ball: *Ball, a: Vector2){
    ball.acceleration = add(ball.acceleration, a);
}

update_position :: (ball: *Ball, delta: float){
    velocity := sub(ball.position, ball.previous_position);
    prev: Vector2 = ball.position;
    ball.previous_position = prev;

    ball.position = add(ball.position, add(velocity, mul_s(ball.acceleration, delta * delta)));
    ball.acceleration = { 0. , 0. };
}

constrain_to_circle :: (ball: *Ball, circle: *Circle){
    displacement := sub(ball.position, circle.centre);
    if length(displacement) > circle.radius - ball.radius {
        value : Vector2 = add(circle.centre, mul_s(normalized(displacement), circle.radius - ball.radius));
        ball.position = value;
    }
}

collide :: (a: *Ball, b: *Ball){
    if a.id == b.id {
        <-;
    }
    axis := sub(a.position, b.position);
    distance := length(axis);
    total_radius := a.radius + b.radius;
    if(distance < total_radius){
        normal := div_s(axis, distance);
        overlap := total_radius - distance;
        offset := mul_s(normal, 0.5 * overlap);
        a.position = add(a.position, offset);
        b.position = sub(b.position, offset);
    }
}

get_balls :: () -> [200]Ball {
    balls: [50]Ball;
    i := 1;
    for ball in balls {
        ball.radius = 10.;
        ball.position = { 400. + float(i) * (ball.radius * 2.0), 500. };
        ball.previous_position = { 400. + float(i) * (ball.radius * 2.0), 500. + float(i) * 0.01 };
        ball.acceleration = { 0., 9.81 };
        ball.id = i;
        i = i + 1;
    }
    <- balls;
}

main :: () {

    window_width := 1500;
    window_height := 1000;

    open_window(window_width, window_height);

    // colours
    orange: Color = { 1., 0.3 + 0.2, 0., 1. };
    blue:   Color = { 0., 0., 1., 1. };
    black:  Color = { 0., 0., 0., 1. };
    white: Color = {1., 1., 1., 1., };

    gravity: Vector2 = { 0. , 9.81 * 40. };

    balls := get_balls();

    environment: Circle = { { 500. , 500. }, 400. };

    start := time_seconds();
    delta := 0.;

    while true {
        frame_begin();
        set_color(&white);
        fill_rect(0, 0, window_width, window_height);

        set_color(&black);
        fill_circle(int(environment.centre.x), int(environment.centre.y), int(environment.radius));

        set_color(&white);

        mouse_position := get_mouse_position();
        balls[50].position = { float(mouse_position.x), float(mouse_position.y) };

        // update
        for ball in balls {
            accelerate(ball, gravity);
        }

        for ball in balls {
            update_position(ball, delta);
            constrain_to_circle(ball, &environment);
        }

        for ball_a in balls {
            for ball_b in balls {
              collide(ball_a, ball_b);
            }
        }


        // render
        for ball in balls {
            fill_circle(int(ball.position.x), int(ball.position.y), int(ball.radius));
        }

        draw();
        current := time_seconds();
        delta = current - start;
        print_float(1.0 / delta);
        start = current;
    }
}